"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [8908], {
        13396: (e, t, n) => {
            n.r(t), n.d(t, {
                PageTransitionsSymbol: () => d.e$,
                editor: () => O,
                editorPage: () => M,
                page: () => B
            });
            var o = n(77748),
                s = n(20590),
                i = n(39218),
                a = n(32166),
                r = n(94715),
                l = n(10553),
                d = n(86046),
                p = n(41596);
            const c = (0, o.Og)([(0, o.KT)(s.Gp, d.UU), (0, o.KT)(s.wk, d.UU), i.dB, p.s, a.RV, r.wN, l.n], (e, t, n, o, s, i, a) => {
                    const r = !!s && "startViewTransition" in s.document && e.shouldUseViewTransition,
                        l = !!a["specs.thunderbolt.shouldUseMpaViewTransition"],
                        d = e.useCssFeatureForViewTransitions;
                    return {
                        name: "pageTransitions",
                        pageWillMount() {
                            if (l && !d) {
                                const t = `<style id="page-transitions">@view-transition {navigation: auto;types: ${e.transitionName}}</style>`;
                                i.setHead(t)
                            }
                        },
                        pageDidMount(o) {
                            const s = t.get(),
                                i = s ? .mountDoneHandler;
                            i && i({
                                transitionName: e.transitionName,
                                pageId: o
                            }), (s ? .isFirstMount ? ? 1) && n.notifyPageTransitionsCompleted(o), t.update(e => ({ ...e,
                                isFirstMount: !1
                            }))
                        },
                        pageWillUnmount({
                            contextId: s
                        }) {
                            const i = t.get();
                            if (r) {
                                const s = () => {
                                        o.getScrollYHistoryState() || o.scrollToTop()
                                    },
                                    i = e => {
                                        n.notifyPageTransitionsCompleted(e), o.getScrollYHistoryState() && o.restoreScrollPosition()
                                    },
                                    a = new Promise(e => {
                                        t.update(t => ({ ...t,
                                            mountDoneHandler: e
                                        }))
                                    });
                                ! function(e, t, n, o) {
                                    let s;
                                    const i = [e.transitionName],
                                        a = document.startViewTransition({
                                            update: () => t.then(e => {
                                                s = e.pageId
                                            }),
                                            types: i
                                        });
                                    a.ready.then(n), a.finished.then(() => {
                                        o(s)
                                    })
                                }(e, a, s, i)
                            }
                            i ? .propsUpdateListenersUnsubscribers ? .[s] ? .(), t.update(e => {
                                const t = e ? .propsUpdateListenersUnsubscribers ? ? {};
                                return delete t[s], { ...e,
                                    propsUpdateListenersUnsubscribers: t
                                }
                            })
                        }
                    }
                }),
                u = (0, o.Og)([(0, o.KT)(s.wk, d.UU)], e => ({
                    disableNextTransition: () => e.update(e => ({ ...e,
                        nextTransitionEnabled: !1
                    }))
                })),
                g = (0, o.Og)([(0, o.KT)(s.Gp, d.UU)], e => {
                    let t = [];
                    return {
                        hasTransition: "none" !== e.transitionName,
                        onPageTransitionsCompleted: e => {
                            t.push(e)
                        },
                        notifyPageTransitionsCompleted: e => {
                            t.forEach(t => t(e)), t = []
                        }
                    }
                });
            var T = n(16537),
                m = n(20636),
                y = n(87711),
                U = n(84448);
            const b = (0, o.Og)([(0, o.KT)(s.Gp, d.UU), y.Ji, i.dB, p.s, (0, o.KT)(s.wk, d.UU), a.RV, l.n, U.W], (e, t, n, o, s, i, a, r) => ({
                componentTypes: ["Page"],
                componentWillMount(l) {
                    const d = s.get(),
                        p = !d || d.nextTransitionEnabled,
                        c = !d || d.isFirstMount,
                        u = !!i && "startViewTransition" in i.document && e.shouldUseViewTransition,
                        g = l.id;
                    t.update({
                        SITE_PAGES: {
                            transitionEnabled: p,
                            ...u ? {} : {
                                onTransitionStarting: () => {
                                    if (o.getScrollYHistoryState() || o.scrollToTop(a["specs.thunderbolt.pageTransitionScrollSmoothly"] ? "smooth" : void 0), a["specs.thunderbolt.postTransitionElementFocus"])
                                        if (r.isFirstPage()) {
                                            const e = window.document.getElementById("SCROLL_TO_TOP");
                                            e ? .focus()
                                        } else {
                                            const e = window.document.querySelector("main section");
                                            e ? .focus({
                                                preventScroll: !0
                                            })
                                        }
                                },
                                onTransitionComplete: () => {
                                    n.notifyPageTransitionsCompleted(g), o.getScrollYHistoryState() && o.restoreScrollPosition()
                                }
                            }
                        }
                    }), s.update(() => ({ ...d,
                        isFirstMount: c,
                        nextTransitionEnabled: !0
                    }))
                }
            }));
            var f = n(62155),
                P = n.n(f),
                w = n(57188);
            const h = ["video.videoInfo.videoId", "image.uri", "image.link.href", "image.displayMode", "backgroundImage.uri", "backgroundImage.link.href", "backgroundImage.displayMode"],
                k = ["type", "alignType", "fittingType", "scrollType", "colorOverlay", "colorOverlayOpacity", "color", "opacity"],
                v = (e, t, n, o) => o.every(n => (e && e[n]) === (t && t[n])) && n.every(s => !e && !t || v(e && e[s], t && t[s], n, o)),
                S = (0, o.Og)([(0, o.KT)(s.Gp, d.UU), y.Ji, (0, o.KT)(s.wk, d.UU), i.Is, i.DR, y.eZ, l.n], (e, t, n, o, s, i, a) => {
                    const r = (0, w.Pb)(o),
                        l = (s, l) => {
                            n.update(t => ({ ...t,
                                pageBackgroundProp: s,
                                pageBackground: e.pageBackground
                            }));
                            const d = a["specs.thunderbolt.pageBGTransitionHandler"],
                                p = n.get() ? .lastRenderedPageBgId,
                                c = !p || i.get(p),
                                u = (n.get() ? .nextTransitionEnabled ? ? !0) && l;
                            let g;
                            if (d) {
                                const t = e.isEditor && !e.isPreview;
                                g = u || t && !c
                            } else g = u || !c;
                            g && n.update(e => ({ ...e,
                                lastRenderedPageBgId: r
                            })), t.update({
                                BACKGROUND_GROUP: {
                                    key: `BACKGROUND_GROUP_${e.viewMode}`,
                                    transitionEnabled: g,
                                    className: `backgroundGroup_${o}`
                                }
                            })
                        },
                        d = t => {
                            const o = n.get(),
                                s = o ? .pageBackgroundProp,
                                i = e.pageBackground,
                                a = o ? .pageBackground,
                                r = !((e, t) => {
                                    if (!t || !e) return !1;
                                    const n = t.mediaRef,
                                        o = n && n.type,
                                        s = e.mediaRef,
                                        i = s && s.type,
                                        a = !n && !s,
                                        r = a || o === i;
                                    let l = [...k];
                                    if ("WixVideo" === o && r) {
                                        const e = l.indexOf("color");
                                        l.splice(e, 1)
                                    } else a && (l = ["color"]);
                                    return r && v(t, e, ["mediaRef", "imageOverlay"], l)
                                })(i, a);
                            return l = t, !((d = s) && l && h.every(e => P().get(d, e) === P().get(l, e))) || r;
                            var l, d
                        };
                    if (t.get(r)) {
                        const e = t.get(r).fillLayers,
                            n = d(e);
                        l(e, n)
                    }
                    const p = t.subscribeToChanges(e => {
                        if (r in e) {
                            const t = e[r] ? .fillLayers;
                            d(t) && l(t, !0)
                        }
                    });
                    return n.update(e => {
                        const t = e ? .propsUpdateListenersUnsubscribers ? ? {};
                        return t[s] = p, { ...e || {},
                            propsUpdateListenersUnsubscribers: t
                        }
                    }), {
                        componentTypes: ["PageBackground"],
                        componentWillMount() {
                            const e = n.get(),
                                t = e ? .isFirstMount ? ? !0;
                            n.update(() => ({ ...e,
                                isFirstMount: t
                            }))
                        }
                    }
                }),
                B = e => {
                    e(i.dB).to(g), e(d.e$).to(u), e(T.$.PageWillMountHandler, T.$.PageDidMountHandler, T.$.PageWillUnmountHandler).to(c), e(m.ls).to(b), e(m.ls).to(S)
                },
                M = e => {
                    e(T.$.PageDidMountHandler, T.$.PageWillUnmountHandler).to(c), e(m.ls).to(b), e(m.ls).to(S)
                },
                O = e => {
                    e(d.e$).to(u), e(i.dB).to(g)
                }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/group_32.f6e41f81.chunk.min.js.map